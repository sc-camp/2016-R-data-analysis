{
    "contents" : "\n##\n# ggplot code for ANCOVA practical\n#\n# Also includes some dplyr code for streamlining parts of the exercise.\n#\n# Assumes data and models etc already in project workspace...\n#\n##\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\n\n\n#### Root:Fruit (Grazing) ####\n\n##\n# Assumes data and models already created \n##\n\nNEWGRAZED<-expand.grid(GRAZING=\"Grazed\",ROOT=seq(4,11,0.1))\nNEWUNGRAZED<-expand.grid(GRAZING=\"Ungrazed\",ROOT=seq(4,11,0.1))\n# have a look at what this produces!\nhead(NEWGRAZED)\n\n\n# the predicted y values come by using the predict command and specifying which vector to substitute for \n# the x variables in the original regression. Note that here we need to tell the predict command where to find \n# the Grazing level as well as the Root measure\n# The argument int=\"c\" tells matlines to draw 95% confidence intervals\nYVGRAZED<-predict(MOD.G1,list(GRAZING=NEWGRAZED$GRAZING,ROOT=NEWGRAZED$ROOT),int=\"c\")\nYVUNGRAZED<-predict(MOD.G1,list(GRAZING=NEWUNGRAZED$GRAZING,ROOT=NEWUNGRAZED$ROOT),int=\"c\")\n\n\ndf_graze_pred <- data_frame(GRAZING = factor(c(rep(\"Grazing\", \n                                                   times = length(NEWGRAZED$GRAZING)), \n                                               rep(\"Ungrazed\",\n                                                   times = length(NEWUNGRAZED$GRAZING)))),\n                            ROOT = c(NEWGRAZED$ROOT, NEWUNGRAZED$ROOT),\n                            FRUIT_PRED = as.numeric(c(YVGRAZED[,\"fit\"], YVUNGRAZED[,\"fit\"])),\n                            FRUIT_LWR = as.numeric(c(YVGRAZED[,\"lwr\"], YVUNGRAZED[,\"lwr\"])),\n                            FRUIT_UPR = as.numeric(c(YVGRAZED[,\"upr\"], YVUNGRAZED[,\"upr\"])))\n\n##\n# Create ggplot from predicted data,\n#  then plot points over the top of this\n##\nggplot(df_graze_pred, aes(x = ROOT, y = FRUIT_PRED,\n                          group = GRAZING)) +\n  geom_line() +\n  geom_ribbon(aes(ymin = FRUIT_LWR,\n                  ymax = FRUIT_UPR),\n              alpha = 0.1) +\n  geom_point(data = COMP, aes(x = ROOT, y = FRUIT,\n                              colour = GRAZING),\n             size = 4, alpha = 0.7) +\n  labs(x = \"Initial root diameter\",\n       y = \"Seed production\") +\n  theme_classic()\n\n\n#### Supplementary exercise ####\n\nWEIGHTS<-read.csv(\"growth.csv\")\n\n##\n# Use dplyr for means and sds\n##\n\nWEIGHTS %>% \n  group_by(DIET, SUPPLEMENT) %>% \n  summarise(mean_gain = mean(GAIN),\n            sd_gain = sd(GAIN))\n\nWEIGHTS$SUPPLEMENT<-relevel(WEIGHTS$SUPPLEMENT,ref=\"control\")\n\n\n# plot the data\nggplot(WEIGHTS, aes(x = SUPPLEMENT, y = GAIN,\n                    colour = DIET)) +\n  geom_boxplot() +\n  theme_classic()\n\n\n\n\n\n# looks like both factors affect weight GAIN, but no real indication of interaction\n\n# build a model\nMOD.1<-lm(GAIN~DIET*SUPPLEMENT,data=WEIGHTS)\n# recall that the * operator indicates an interaction, and the hypothesis addressed by the interaction term is something like: does the effect of DIET depend on SUPPLEMENT?\n\n\npar(mfrow=c(2,3))\nplot(MOD.1)\nhist(MOD.1$residuals)\npar(mfrow=c(1,1))\n# diags not pretty, but maybe simp will help\n\nsummary(MOD.1)\n# make sure you can interpret each of these parameter estimates! \n\n# as we suspected, none of interaction estimates seem important, so try simplification\nMOD.2<-update(MOD.1,~. -DIET:SUPPLEMENT)\nanova(MOD.1,MOD.2)\n# we're OK to remove the interaction\n# note that the P-value of the F test is the same as that provided by the anova table, below\nsummary.aov(MOD.1)\n\n\nsummary(MOD.2)\n# notice how many parameters were being sucked up by the interaction!\n\n# inspect the new model's diagnostics\npar(mfrow=c(2,3))\nplot(MOD.2)\nhist(MOD.2$residuals)\npar(mfrow=c(1,1))\n# better!! this often happens as you approach a good model\n\n\n# try to simplify further\nMOD.3<-update(MOD.2,~. -SUPPLEMENT)\nanova(MOD.2,MOD.3)\n\nMOD.4<-update(MOD.2,~. -DIET)\nanova(MOD.2,MOD.4)\n# as expected, no further simplification is possible at the level of main effects\n\n# however, you could try consolidating subgroups of treatments based on observing that the two best SUPPLEMENTs seem to outperform the two worst ones\n# the code to do this is below\n\n##\n# Use dplyr to explicitly code a new variable\n##\n\nWEIGHTS <- WEIGHTS %>% \n  mutate(SUPP2 = factor(ifelse(SUPPLEMENT %in% c(\"agrimore\",\"supersupp\"),\n                               \"best\", \"worst\")))\n\n\nMOD.5<-lm(GAIN~DIET+SUPP2,data=WEIGHTS)\nanova(MOD.2,MOD.5)\n\n# this analysis suggests the recoding is worth doing, as the model deviance is not substantially increased by having four levels of SUPPLEMENT instead of two\n# so the minimal adequate model is MOD.5\nsummary(MOD.5)\n\n# check the diagnostics again\npar(mfrow=c(2,3))\nplot(MOD.5)\nhist(MOD.5$residuals)\npar(mfrow=c(1,1))\n# and the diagnostics for this model are even better!\n\n\n# first, save the means, sd's and sample sizes of all treatment combinations in\n# named tapply objects (these objects are classed as matrices, and are treated\n# differently from dataframes in recognition of their different structure, i.e.,\n# they contain the same \"kind\" of variable in both rows and columns) tapply\n# needs as input the variable to summarize, then a list containing the factor\n# variables, then the function to apply to the records belonging in each factor\n# group\nGAIN_INFO <- WEIGHTS %>% \n  group_by(SUPPLEMENT, DIET) %>% \n  summarise(mean_gain = mean(GAIN),\n            sd_gain = sd(GAIN),\n            n_gain = n())\n  \n# have a look!\nGAIN_INFO\n# note the well-balanced experimental design, with equal replication in all\n# groups!\n\n\n##\n# Using ggplot to create bar plots, with supplement as main x-axis\n#  but also separate bars for each diet within those groups.\n#\n# Within the call to geom_bar, I call 'identity' for the statistical\n#  transformation to tell ggplot that I want the bar to just represent the \n#  value in the associated row (because we have already worked out the means).\n#\n# I also use 'position=\"dodge\"' to describe how the bars should be positioned.\n# Have a look at the documentation for geom_bar to find out more...\n#\n# geom_errorbar creates error bars; by default, the crossbars are the same width\n#  as your main bars, but I prefer to shrink the width. This does mess with the \n#  positioning of the error bars though, so I have used 'position' to move these\n#  slightly.\n#\n# 'scale_fill_grey' tells ggplot that, for the variable we have specified in\n#   the aesthetics to give different 'fill' colours to, I want to use shades \n#   of grey (and ggplot will make as many as required)\n#\n# I have annotated the figure with the 'N=x' labels for every bar;\n#  I use 'paste' to create a vector of labels, and also assign a value\n#  to a variable I've called 'bump' to say how much I want to move the labels\n#  from a position for each group of bars (play around with this to see what\n#  I mean!)\n\nannot_lab = paste(\"N=\", GAIN_INFO$n_gain)\nbump <- 0.3\n\nggplot(GAIN_INFO, aes(x = SUPPLEMENT, y = mean_gain,\n                      fill = DIET)) +\n  geom_bar(stat=\"identity\",\n           position=\"dodge\") +\n  geom_errorbar(aes(ymin = mean_gain - sd_gain,\n                    ymax = mean_gain + sd_gain),\n                position = position_dodge(width = 0.9),\n                width = 0.25) +\n  scale_fill_grey() +\n  labs(x = \"Supplement\",\n       y = \"Mass gain (kg)\") +\n  annotate(\"text\", \n           x = c(1-bump,1,1+bump,\n                 2-bump,2,2+bump,\n                 3-bump,3,3+bump,\n                 4-bump,4,4+bump), \n           y = -0.8, \n           label = annot_lab) +\n  theme_classic()\n\n\n\n\n\n",
    "created" : 1449162935073.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1523962314",
    "id" : "78052A6",
    "lastKnownWriteTime" : 1449055648,
    "path" : "~/Documents/formations/R - Ecosse/courses/Updates/AdvInR_Ancova_ggplot.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}