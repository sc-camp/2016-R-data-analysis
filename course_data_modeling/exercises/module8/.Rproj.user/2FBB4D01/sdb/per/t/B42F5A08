{
    "contents" : "#Mixed effects models\n#AdvInR\n\n#Script developed by Nils Bunnefeld, and modified by Luc Bussi√®re November 2015\n\n\n###### GROUSE SHOOTING ######\n\n# clear workspace\nrm(list=ls())\n\n# analysis of grouse\n# import data file\nGROUSE<-read.csv(\"grouse_shooting_mod.csv\")\nstr(GROUSE)\n\n# first will want to divide nr_shot by drive size to facilitate contrasts\nGROUSE$shotperkm<-GROUSE$nr_shot/GROUSE$km2\n# then examine distribution\nhist(GROUSE$shotperkm)\n# variable is bounded below and count data\n# to keep things simple, let's see if a log transform will help\nhist(log(GROUSE$shotperkm))\n# looks like this will be better even if not perfect\n# let's store the vector for later use\nGROUSE$shot<-log(GROUSE$shotperkm)\n\n# the counts will similarly need a log transform\nGROUSE$count<-log(GROUSE$totalcount)\n\n# now plot the relationship and predict effects\nplot(shot~count,data=GROUSE)\n# looks like a positive linear relationship (in log-log space), with slope approx 1\nplot(shot~jitter(prev),data=GROUSE)\n# looks like a negative relationship, maybe with slope around -0.5??\n\n# but recall that we would really like to know ahead of time whether there is an interaction\n# let's build a plot that separately illustrates the effects of previous shooting number on count\nlibrary(ggplot2)\nggplot(GROUSE, aes(x = count, y = shot)) + \n  geom_point() + \n  stat_smooth(method = \"lm\") +\n  facet_grid(. ~ prev)\n# there is no strong evidence from these plots for an interaction, because the lines are more or less parallel\n# however, it does look like the numbers of shot grouse are highest in the first shooting, followed by the second and third \n\n\n# to start, let's keep things simple with the maximal linear model\ng1<-lm(shot~count*prev,data=GROUSE)\npar(mfrow=c(2,2))\nplot(g1)\npar(mfrow=c(1,1))\n# QQ plot looks a bit weak, others OK\nsummary(g1)\n# guess at coefficient for count not bad, but other suffers -- however interaction still in so model needs simplifying\n\ng2<-update(g1,~. -count:prev)\nanova(g1,g2)\n# simpler model better, as expected\n\npar(mfrow=c(2,2))\nplot(g2)\npar(mfrow=c(1,1))\n# QQ maybe slightly better, still a bit poor\nsummary(g2)\n# now guess for coefficients quite good, and supported statistically\n\n# can't simplify further, because p-vals for linear models are already for p-on-deletion\n\n# problems is that this linear model features pseudoreplication\n# both moor and drive visited repeatedly, and would like to soak up the variance assoc with these factors\n\n# but having done the fixed version of the model gives us a good idea of what to expect from a successful mixed mode, so it was worth starting there!\n\n\n#Extending the linear model to account for pseudoreplication\n\n#We know that we also have repeated measurements for some drives (hunting area) and drive is nested within moor (management unit owned by a single land owner). We need to address this by specifying the random effects in the model. \n\n# What if we didn't use mixed effects models and added moor and drive as fixed effects? Let's try it out. \n\ng4<-lm(shot~moor+drive+prev+count,data=GROUSE)\nsummary(g4)\n\n#Why are there NA estimates in the summary output?\n# Try these tables which tell you how many of each combination of moor and drive (and previous numbers of shootings) there are\nxtabs(~moor+drive,data=GROUSE)\nxtabs(~moor+drive+prev,data=GROUSE)\n\n# most combinations are poorly represented, and the small overall sample means we don't have the degrees of freedom to estimate all the coefficients needed for a fixed model\n\n#Let's try the same analysis in a mixed effect model framewoprk. In mixed effects models, we need to specify the random part of the model.\n# I prefer the syntax of lme4 to that of nlme, but both are OK\nlibrary(lme4)\n\ng1.mixed<-lmer(shot~prev*count+(1|moor)+(1|drive),data=GROUSE)\n\n# not clear which diagnostics are most relevant, but can call the next one easily\nplot(g1.mixed)\n\n# also other plots that can clarify the dist of random effects for example\nlibrary(sjPlot)\nlibrary(arm)\nsjp.lmer(g1.mixed)\nsummary(g1.mixed)\n\n\n#Can do a variance components analysis, which is basically extracting the variance from the random effects and calculating the relative contribution of each term of the random effects to the total variation explained by the random effects. Extract the variance for all levels plus the residual variance from the summary().\n\nvars<- c(0.04510,0.08102,0.13114)\nvars/sum(vars)  \n\n# these values will change if you can simplify the model, so you may want to repeat this exercise on your min adequate model later on\n\n# notice how there are no p-values, because it's not clear what denominator df are in mixed models\n\n# but R will let us assess significance by simplifying, even though there is substantial debate about whether this is a good method for judging significance of terms\ng2.mixed<-update(g1.mixed,~. - prev:count)\nanova(g1.mixed,g2.mixed)\n# notice the message in red telling us that R has refit the models using a different estimation procedure -- we compare models fit with ML, but report coefficients fit with REML\n\n# the simpler model is preferred (if we believe the likelihood ratio test method for testing significance)\nsummary(g2.mixed)\n# can we simplify further?\ng3.mixed<-update(g2.mixed,~. - prev)\nanova(g3.mixed,g2.mixed)\n# can't lose prev\ng4.mixed<-update(g2.mixed,~. - count)\nanova(g4.mixed,g2.mixed)\n# can't lose count either\n# if we care about p-values, the two LR tests have provided some for us\n\n# so min adequate model is g2.mixed\nsummary(g2.mixed)\n# coeffs similar but not identical to those in fixed model\n# why are df known for model simp, but not for tests of coefs?\n\n# could also compare models with AIC\n# because sample is small, may prefer AICc\n# may need to install MuMIn, which has one implementation of AICc\nlibrary(MuMIn)\n\nAICc(g1.mixed,g2.mixed,g3.mixed,g4.mixed)\n# methods are in agreement\n# best model is g2.mixed\n\n#The summary looks like the one from linear models, but we have additional parts here. The most important are the variances of the random effects and th enumber of observations to check that we have done the right thing. Try to understand the three different parts, the random effects, the fixed effects and the data structure (Number of obs).\n\n\n#report the predictions of the best fitting model using REML=TRUE because REML gives more robust estimates then ML; but REML is not suited for model comparison. \n \n##\n# We can use {broom}, {dplyr} and {ggplot} to look at fitted points\n#  for our model...\n##\n\nlibrary(broom)\nlibrary(dplyr)\n\n## 'Augment' gives the fitted response for the x value at each point\n## - we can plot actual data points and then very slightly jitter the fits\n##   in red to visualise what our model is telling us...\naugment(g2.mixed) %>%\n  ggplot(., aes(x = count, y = shot)) +\n  geom_point() +\n  geom_jitter(aes(x = count, y = .fitted),\n              colour = \"red\") +\n  facet_grid(.~prev)\n\n## Note that, unlikely standard linear regression, we obviously\n##  cannot draw a straight line through our fitted points!\n## This is because augment has given us the predicted value\n##  from random effects by default (i.e., it retains the information\n##  about moor and drive when predicting 'shot' from 'count').\n## We can also plot the line given by our fixed effects ONLY by using\n##  '.fixed' instead of '.fitted':\n\naugment(g2.mixed) %>%\n  ggplot(., aes(x = count, y = shot)) +\n  geom_point() +\n  geom_jitter(aes(x = count, y = .fitted),\n              colour = \"red\") +\n  geom_line(aes(x = count, y = .fixed)) +\n  facet_grid(.~prev)\n\n## Try plotting quickly with visreg\nlibrary(visreg)\n\n\n## Plot the model...\nvisreg(g2.mixed,xvar=\"count\",by=\"prev\")\n\n## Overlay 'prev'\nvisreg(g2.mixed,xvar=\"count\",by=\"prev\", overlay = TRUE)\n\n\n##\n# Can also plot separately for our different random effects\n##\n\n## Moor\nvisreg(g2.mixed, \n       xvar = \"count\", \n       by = \"moor\")\n\n## Drive\nvisreg(g2.mixed, \n       xvar = \"count\", \n       by = \"drive\")\n\n##\n# Plots the points separately but our slopes are the same,\n#  always taken from just our fixed effects.\n##\n\n##\n# We could build plots with separate slopes for moors / drives\n#  but it would be a bit of a hassle, as even broom isn't that \n#  great for this question:\n##\naugment(g2.mixed)\n\n##\n#  broom has automatically given us the predictions based\n#  on the combination of random effects for each actual observation... \n#  the other problem is that this data set doesn't have many observations!\n##\n\n## 'tidy' also gives us estimates for random effects by default:\ntidy(g2.mixed)\n\n## ...but we can get tidied fixed effects too:\ntidy(g2.mixed, effects = \"fixed\")\n\n##\n# If you have to plot a slope for each moor and drive,\n#  you could compute the slope for each prev*count, with \n#  distinct intercepts as given by the random effects.\n# \n# You may want to head back to the dreaded 'predict' function\n#  for that...\n#\n##\n\n## Make a publication-quality figure ##\n\n## You *probably* would only want the original data points\n##  and your slope from the fixed effects on a \n##  publication-quality plot:\n\n## First make a function to label our facets nicely\nshootlabel <- function(var, value) {\n  if(var == \"prev\"){\n    value[value == 1] <- \"First shoot\"\n    value[value == 2] <- \"Second shoot\"\n    value[value == 3] <- \"Third/fourth shoot\"\n  }\n  return(value)\n}\n\n## You need the {broom} package and {dplyr}...\nlibrary(broom)\nlibrary(dplyr)\n\n## Now make the model, faceted by prev\naugment(g2.mixed) %>%\n  ggplot(., aes(x = count, y = shot)) +\n  geom_point() +\n  geom_line(aes(x = count, y = .fixed)) +\n  labs(y=\"Grouse shot per km2 (log)\",\n       x=\"Grouse counted per km2 (log)\") +\n  facet_grid(.~prev, labeller = shootlabel) +\n  theme_bw()\n\n\n# make a publication quality plot (using base graphics)\n\n# could plot all three lines and all data on a single panel\nplot(shot~count,data=GROUSE,\n     ylab=\"Grouse shot per km2 (log)\",\n     xlab=\"Grouse counted per km2 (log)\",\n     type=\"n\")\n# in the previous line, type =\"n\" suppresses plotting anything, so I can add points by group and better control how the plot looks\n\npoints(shot[prev==\"1\"]~count[prev==\"1\"],data=GROUSE, pch=20)\npoints(shot[prev==\"2\"]~count[prev==\"2\"],col=\"blue\",data=GROUSE,  \n       pch=20)\npoints(shot[prev==\"3\"]~count[prev==\"3\"],col=\"red\",data=GROUSE, \n       pch=20)\nabline(-3.98,1.4)\nabline(-3.98-0.53,1.41,lty=3,col=\"blue\")\nabline(-3.98-0.94,1.41,lty=4,col=\"red\")\n\n\n#IMO this graph looks a bit messy. Use mfrow() to split the graphics area into three separate plotting areas, or use ggplot to make a publication quality figure\n\npar(mfrow=c(1,3))\nplot(shot~count,data=GROUSE,type=\"n\",xlab=\"Grouse counted (log)\", ylab=\"Number of grouse shot (log)\",cex.lab=1.2)\ntitle(main=\"First shooting event\")  \npoints(shot[prev==\"1\"]~count[prev==\"1\"],data=GROUSE,col=\"purple\",pch=20)\nabline(-3.98,1.4,col=\"purple\")\nplot(shot~count,data=GROUSE,type=\"n\",xlab=\" Grouse counted (log)\",ylab=\"\",cex.lab=1.2)\ntitle(main=\"Second shooting event\")\npoints(shot[prev==\"2\"]~count[prev==\"2\"],col=\"blue\",data=GROUSE, \n       pch=20)\nabline(-3.98-0.53,1.41,lty=3,col=\"blue\")\nplot(shot~count,data=GROUSE,type=\"n\",xlab=\" Grouse counted (log)\", ylab=\"\", cex.lab=1.2 )\ntitle(main=\"Third/fourth shooting event\")\npoints(shot[prev==\"3\"]~count[prev==\"3\"],col=\"red\",data=GROUSE, \n       pch=20)\nabline(-3.98-0.94,1.41,lty=4,col=\"red\")\npar(mfrow=c(1,1))\n\n\n##\n# Again, see why ggplot2 is much better... [/TOM]\n##\n\n####### SuppEx (FLIES) #######\n\n# clear workspace\n# rm(list=ls())\n\n# import data file\nFLIES<-read.csv(\"KatieFlies4R.csv\")\nstr(FLIES)\n# recode family ID as factor\nFLIES$Maternal.Fam<-as.factor(FLIES$Maternal.Fam)\nFLIES$Paternal.Fam<-as.factor(FLIES$Paternal.Fam)\nnames(FLIES)\n\n# select males\nMFLIES<-FLIES[FLIES$Sex==\"M\",]\n\n# want to play with data on mass so need to check dist\nhist(MFLIES$Wet.Mass)\n# looks great\n\n# visualize effects of temp on male mass by pop\nlibrary(ggplot2)\nggplot(MFLIES, aes(x = Temp, y = Wet.Mass)) + \n  geom_point() +\n  stat_smooth(method=\"lm\") +\n  facet_grid(.~ Population)\n\n# looks like temp has a negative effect on mass, but maybe in only some sex:pop combinations\n\n# build a fixed model first\nMfixed.mod1<-lm(Wet.Mass~Temp,data=MFLIES)\n\n\npar(mfrow=c(2,2))\nplot(Mfixed.mod1)\npar(mfrow=c(1,1))\n# looks good\nsummary(Mfixed.mod1)\n# support for interaction, but pseudorep\n\n# could add in Population as fixed factor\n\nMfixed.mod2<-lm(Wet.Mass~Temp*Population,data=MFLIES)\npar(mfrow=c(2,2))\nplot(Mfixed.mod2)\npar(mfrow=c(1,1))\n# problems with QQ plot at lower end\nsummary(Mfixed.mod2)\n# seem to be some strong Pop effects, but model the same\n# can I remove Int?\nanova(Mfixed.mod2,Mfixed.mod1)\n# nope\n\n# F test says we need to keep int, but this is still pseudoreplicated\n\n\n\n# so now try mixed model, first without \"interaction\" between temp and Pop\nnames(MFLIES)\nlibrary(lme4)\nMmixed.mod1<-lmer(Wet.Mass~Temp*Population+(1|Maternal.Fam)+(1|Paternal.Fam),data=MFLIES)\n\nsummary(Mmixed.mod1)\nvcov(Mmixed.mod1)\n# population not soaking up much variance\n\n# is it important?\nMmixed.mod2<-update(Mmixed.mod1,~. - Temp:Population)\nanova(Mmixed.mod1,Mmixed.mod2)\n# yup, so far\n\n# OK now, let's try fitting pop as a random effect\nMmixed.mod3<-lmer(Wet.Mass~Temp+(1|Population)+(1|Maternal.Fam)+(1|Paternal.Fam),data=MFLIES)\n\nsummary(Mmixed.mod3)\n# simpler output, but no temp by pop int\n\n# now can we get effects of temp to vary by population?\nMmixed.mod4<-lmer(Wet.Mass~Temp+(Temp|Population)+(1|Maternal.Fam)+(1|Paternal.Fam),data=MFLIES)\n\nanova(Mmixed.mod4,Mmixed.mod3)\n# mod 4 slightly better than mod3\n\n# examine diagnostics now? a bit late, but until now we were converging on the big model\nplot(Mmixed.mod4)\nsjp.lmer(Mmixed.mod4)\n\nsummary(Mmixed.mod4)\n\n\n\n# now how to illustrate effects\nstr(Mmixed.mod4)\nstr(MFLIES)\nNEWTEMP<-expand.grid(Temp=seq(18,22,length=10),Population=levels(MFLIES$Population),Maternal.Fam=levels(MFLIES$Maternal.Fam),Paternal.Fam=levels(MFLIES$Paternal.Fam))\nPREDMASS<-predict(Mmixed.mod4,newdata=NEWTEMP,re.form=~(Temp|Population))\n\nPREDSFRAME<-cbind(NEWTEMP,PREDMASS)\nhead(PREDSFRAME)\n\n# figure below needs cleaning (with proper labels for axes and pops, but you get the idea)\nggplot(PREDSFRAME, aes(x = Temp, y = PREDMASS)) + \n  geom_line() +\n  facet_grid(. ~ Population)\n\n##\n# Remember that visreg only gives the fitted slope from the fixed effects,\n#  but will plot the points separately for different groups in the random effects\n##\n\n## Show the fitted slope for each population\nvisreg(Mmixed.mod4, \n       xvar = \"Temp\", \n       by = \"Population\")\n\n## Now by each maternal family\nvisreg(Mmixed.mod4, \n       xvar = \"Temp\", \n       by = \"Maternal.Fam\")\n\n## ...and paternal family\nvisreg(Mmixed.mod4, \n       xvar = \"Temp\", \n       by = \"Paternal.Fam\")\n\n\n## Overlay basically just colours the points as obviously the \n##  slope is the same\nvisreg(Mmixed.mod4, \n       xvar = \"Temp\", \n       by = \"Population\",\n       overlay = TRUE)\n\n",
    "created" : 1449160908121.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2188982226",
    "id" : "B42F5A08",
    "lastKnownWriteTime" : 1448834482,
    "path" : "~/Documents/formations/R - Ecosse/courses/Mod_8_mixed_mods/AdvInR_Mixed_effects_models_practical.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}