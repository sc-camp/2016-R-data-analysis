{
    "contents" : "\n##\n#\n# 'Advancing in R' course\n#\n# Manipulating data\n#\n##\n\n# Install packages if necessary\n# install.packages(c(\"tidyr\", \"dplyr\"))\n\n# Load tidyr and dplyr packages\nlibrary(tidyr)\nlibrary(dplyr)\n\n##### Tidying data: Peppered moth counts ####\n\n# import the data; note that read.csv works for comma delimited files\nMOTHS <- read.csv(\"MothCount.csv\")\n\n# examine data\nMOTHS\n\n##\n# First, sex is already in a column, but needs to be named\n#  (it was left blank in the original spreadsheet).\n# Second, when we rearrange our morph types into key/value pairs,\n#  we don't want each value to be 'x.morph'; we want 'x'.\n#\n# Let's use dplyr's 'rename' function to specify new column names.\n#\n# We assign these changes to the MOTHS object, overwriting the \n#  original version.\n##\nMOTHS <- rename(MOTHS, \n               Sex = X,\n               Dark = Dark.morph, \n               Light = Light.morph)\n\n# Check these changes:\nMOTHS\n\n##\n# Convert our data into key/value pairs using 'gather'\n# - 1. data [MOTHS]\n# - 2. key / value column names to create [Morph, Count]\n# - 3. columns to gather [Dark:Light]\n##\n\nMOTHS_T <- gather(MOTHS, \n                 Morph, Count, \n                 Dark:Light)\n\nMOTHS_T\n\n\n## 'spread' is the complement of 'gather' (reverts back to 'wide' format)\nspread(MOTHS_T, Morph, Count)\n\n##\n# Tidy format enables us to start exploring our data more easily...\n##\n\nMOTHS_T %>%\n  select(Sex, Count) %>%\t\n  group_by(Sex) %>%\n  summarise(SexCount = n()) %>%\n  mutate(Proportion = SexCount/sum(SexCount))\n         \n\n\n##### Tidying data: Time series (city weather) ####\n\n# import the data\nCITYTEMPS <- read.csv(\"TOM_CITIES.csv\")\n\n# examine data\nCITYTEMPS\n\n# look at the initial conversion to 'long' format\ngather(CITYTEMPS, \n       Day, Temperature, \n       Day.1:Day.10)\n\n\n# Having 'Day.x' isn't actually all that helpful!\n# Use 'separate' to extract the value required\ngather(CITYTEMPS, \n       Day, Temperature, \n       Day.1:Day.10) %>% \n  separate(Day, into=c(\"tmp\",\"Day\")) \n\n\n\n##### Manipulating data: Exploring weather data ####\n\n##\n# Load in the weather data file\n##\n\nWEATHER <- read.csv(\"UKWeatherData.csv\")\n\nstr(WEATHER)\n\n\n########## Q1 List the locations with the highest temperature in each year #######\n\n## \n# First, there are a lot of variables that we're not interested in,\n#  so we can just select those that we want to keep...\n##\n\n## Select Location, Year, Month, and TempMax\nWEATHER %>% \n  select(Location, Year, Month, TempMax) \n\n##\n# Too many rows! Chain 'head' to the end of our command\n#  to get the first few rows.\n# Use the documentation to see how you can change the \n#  number that are returned (default is 6)\n## \nWEATHER %>% \n  select(Location, Year, Month, TempMax) %>%\n  head(n = 10)\n\n## ... which is equivalent to using\nWEATHER %>% \n  select(-c(TempMin, AF, Rainfall, Sun)) %>%\n  head(n = 10)\n\nWEATHER %>% \n  select(-TempMin, -AF, -Rainfall, -Sun) %>%\n  head(n = 10)\n\n## We could also take advantage of the order of the variables:\nWEATHER %>% \n  select(Location:TempMax) %>%\n  head(n = 10)\n\n## Now arrange these in descending order of year & TempMax\nWEATHER %>% \n  select(Location, Year, Month, TempMax) %>%\n  arrange(desc(Year), desc(TempMax)) %>%\n  head(n = 10)\n\n\n## \n# You'll notice some of these temperatures seem quite low\n#  - this is because we sorted first by Year, and the data set\n#    only gives readings up until March 2015.\n##\n\n\nWEATHER %>% \n  select(Month, Year) %>% \n  distinct(Month, Year) %>% \n  arrange(desc(Year), desc(Month)) %>% \n  head(n = 20)\n\n##\n#  We can use a filter to only use values until the end of 2014.\n##\n\nWEATHER %>% \n  select(Location, Year, Month, TempMax) %>% \n  filter(Year <= 2014) %>%\n  arrange(desc(Year), desc(TempMax)) %>%\n  head(n = 10)\n\n## \n# That seems more like it!\n# Also note that we put the filter before the arrange command,\n#  as this reduces the number of records that R has to sort.\n##\n\nWEATHER <- WEATHER %>% \n  filter(Year <= 2014)\n\n\n##\n# Now, let's find the location with the highest monthly max temp\n#  in each year. using the 'distinct' function.\n##\nWEATHER %>% \n  select(Location, Year, Month, TempMax) %>% \n  arrange(desc(Year), desc(TempMax)) %>%\n  distinct(Year) \n\n\n##\n# Check the documentation to see more about 'distinct'\n# - in particular, think about why this is placed AFTER the \n# 'arrange' command.\n##\n\n##\n# How would you find the location with the minimum temperature for \n#  each month of 1967?\n#\n# HINT: Think about how you should filter the data, as well as how\n#        to arrange the rows before selecting a 'distinct' one.\n##\n\nWEATHER %>% \n  select(Location, Year, Month, TempMin) %>% \n  filter(Year == 1975) %>%\n  arrange(Month, TempMin) %>%\n  distinct(Month) \n\n#\n# How would you find the year with the highest monthly max temp\n#  for each location?\n#\n# HINT: Think about how the rows are arranged, as well as the variable\n#        you are selecting as 'distinct'.\n##\n\nWEATHER %>% \n  select(Location, Year, Month, TempMax) %>% \n  arrange(desc(TempMax)) %>%\n  distinct(Location) \n\n\n\n\n\n\n########## Q2 Top 5 locations with highest total rainfall from 2000-2014 #######\n\n##\n# Use the 'split-apply-combine' technique:\n##\n\nWEATHER %>%\n  filter(Year >= 2000) %>%\n  group_by(Location) %>%\n  summarise(totalrain = sum(Rainfall, na.rm = TRUE)) %>%\n  arrange(desc(totalrain)) %>%\n  head(n = 5)\n\n##\n# - split data by location\n# - apply a summary function to each group\n# - combine these summary statistics\n##\n\n##\n# Bonus questions\n##\n\n## Find the average monthly rainfall for each location in each year, 2010-2014\n##  HINT: You can group by more than one variable...\n\nWEATHER %>%\n  select(Location, Year, Month, Rainfall) %>%\n  filter(Year >= 2010) %>%\n  group_by(Location, Year) %>%\n  summarise(mean_rain = mean(Rainfall, na.rm = TRUE)) %>%\n  arrange(desc(Year)) \n\n## Add the standard deviation; reduce the number of decimal places\nWEATHER %>%\n  select(Location, Year, Month, Rainfall) %>%\n  filter(Year >= 2010) %>%\n  group_by(Location, Year) %>%\n  summarise(mean_rain = round(mean(Rainfall, na.rm = TRUE), digits = 2),\n            sd_rain = round(sd(Rainfall, na.rm = TRUE), digits = 2)) %>%\n  arrange(desc(Year)) \n\n\n## How many hours of sun were recorded each month in 2014?\nWEATHER %>%\n  filter(Year == 2014) %>%\n  group_by(Month) %>%\n  summarise(totalsun = sum(Sun, na.rm = TRUE)) \n\n## For each year, how much rainfall has been recorded in total\n##  (rainfall of all locations across all months)\nWEATHER %>%\n  group_by(Year) %>%\n  summarise(totalrain = sum(Rainfall, na.rm = TRUE)) %>%\n  arrange(desc(Year)) %>%\n  head(n = 10)\n\n## \n# For a given group of stations, what are the annual averages and\n#  standard deviations of hours of sun in 2014?\n##\nWEATHER %>%\n  select(Location, Year, Month, Sun) %>%\n  filter(Year == 2014,\n         Location %in% c(\"Eskdalemuir\", \"Leuchars\",\n                         \"Paisley\", \"Stornoway\")) %>% \n  group_by(Location, Year) %>%\n  summarise(mean_sun = round(mean(Sun, na.rm = TRUE), digits = 2),\n            sd_sun = round(sd(Sun, na.rm = TRUE), digits = 2)) %>%\n  arrange(desc(Year)) \n\n\n######### Q3 Which locations have 2014's biggest monthly temperature range? ##########\n\nWEATHER %>%\n  select(Location, Year, Month, contains(\"Temp\")) %>%\n  filter(Year == 2014) %>%\n  mutate(TempRange = TempMax - TempMin) %>%\n  arrange(desc(TempRange)) %>%\n  head(n = 10)\n\n# Bonus: find the average annual temperature range across all locations\nWEATHER %>%\n  select(Location, Year, Month, contains(\"Temp\")) %>%\n  filter(Year >= 2010) %>%\n  mutate(TempRange = TempMax - TempMin) %>% \n  group_by(Year) %>% \n  summarise(mean_range = mean(TempRange)) \n\n\n######### Q4 Which location has the highest total sun: total rainfall ratio for the 20th century? ##########\n\n\nWEATHER %>%\n  filter(Year >= 1900, Year <= 1999) %>%\n  group_by(Location) %>%\n  summarise(totalrain = sum(Rainfall, na.rm = TRUE),\n            totalsun = sum(Sun, na.rm = TRUE)) %>%\n  mutate(Sun2Rain = totalsun/totalrain) %>%\n  select(-starts_with(\"total\")) %>% \n  arrange(desc(Sun2Rain)) \n\n## Use mutate to add a categorical variable\nWEATHER %>%\n  filter(Year >= 1900, Year <= 1999) %>%\n  group_by(Location) %>%\n  summarise(totalrain = sum(Rainfall, na.rm = TRUE),\n            totalsun = sum(Sun, na.rm = TRUE)) %>%\n  mutate(Sun2Rain = totalsun/totalrain) %>%\n  select(-starts_with(\"total\")) %>% \n  arrange(desc(Sun2Rain)) %>% \n  mutate(SunBin = ifelse(Sun2Rain >= 2, 1, 0))\n\n\n######### Q5 Merge \n\nSTATIONS <- read.csv(\"WeatherStations.csv\")\n\nstr(STATIONS)\nstr(WEATHER)\n\nleft_join(WEATHER, STATIONS,\n           by = \"Location\") %>% \n  head()\n\nWEATHERLOC <- inner_join(WEATHER, STATIONS,\n                         by = \"Location\")\n\nWEATHERLOC %>%\n  filter(Year == 2014 & Month == 6) %>%\n  select(Location, Month, DegN, TempMax) %>%\n  arrange(desc(DegN))\n  \n\n##\n# One facet of grouping and summarising variables is that it ditches\n#  additional information that you may want to keep... for example, if\n#  we want to keep 'DegN' info then we have to group by this as well as\n#  by location. \n# But, this means that 'arrange' will not work with 'DegN' afterwards as\n#  R considers each to be a separate grouping. We can add the 'ungroup'\n#  command to the chain to remove these groupings, allowing us to act on\n#  the data frame as normal\n##\nWEATHERLOC %>%\n  filter(Year == 2014, !is.na(Sun)) %>%\n  select(Location, Month, DegN, Sun) %>%\n  group_by(Location, DegN) %>% \n  summarise(total_sun = sum(Sun, na.rm = TRUE)) %>% \n  #ungroup() %>% \n  arrange(desc(DegN)) %>% \n  print.data.frame()\n\n\n###### Supplementary exercises ######\n\n##### SE (bonus): Finish reshaping earlier time series data ####\n\ngather(CITYTEMPS, \n       Day, Temperature, \n       Day.1:Day.10) %>% \n  separate(Day, into=c(\"tmp\",\"Day\")) %>% \n  select(-tmp) %>% \n  mutate(Day = as.numeric(Day)) %>% \n  arrange(City, Day)\n\n\n##### SE1: Reshaping and separating time series data #####\n\n\nOBK <- read.csv(\"OBrienKaiser.csv\")\n\nstr(OBK)\n\n# Check how the default sep works...\nOBK %>%\n  rename(ID = X) %>%\n  gather(Time, Measurement, pre.1:fup.5) %>%\n  separate(Time, into = c(\"Period\", \"Time\")) %>%\n  head(30)\n\n# Here is how you specify '.' as separator if desired\nOBK %>%\n  rename(ID = X) %>%\n  gather(Time, Measurement, pre.1:fup.5) %>%\n  separate(Time, into = c(\"Period\", \"Time\"), sep = \"\\\\.\") %>%\n  head(30)\n\n# Use 'mutate' to convert some variable types\nOBK %>%\n  rename(ID = X) %>%\n  gather(Time, Measurement, pre.1:fup.5) %>%\n  separate(Time, into = c(\"Period\", \"Time\")) %>%\n  mutate(ID = factor(ID),\n         Period = factor(Period),\n         Time = as.numeric(Time),\n         Measurement = as.numeric(Measurement)) %>% \n  str()\n\n\n##### SE 2: Creating 'quarterly' variable for Weather data ######\n\n# Using 'ifelse'\nWEATHER %>% \n  mutate(Q = ifelse(Month <= 3,1,\n                    ifelse(Month <= 6,2,\n                           ifelse(Month <= 9,3,4)))) %>% \n  head(10)\n\n# Using left_join\ndf_Q <- data_frame(Month = c(1:12),\n                   Q = rep(1:4, each = 3))\n\nleft_join(WEATHER, df_Q) %>% \n  head(10)\n\n\n\n###### SE 3: Joining by more than one variable ######\n\n## CONTENT\n\n\n###### Bonus 1: summarising individual-level moth data ######\n\nMOTH_MASS <- read.csv(\"MOTH_MASS.csv\")\n\nstr(MOTH_MASS)\n\n## Find the sex-specific means and standard deviations of mass\nMOTH_MASS %>%\n  group_by(SEX) %>%\n  summarise(Mass_mean = mean(MASS),\n            Mass_sd = round(sd(MASS), digits = 2))\n\n## Add further information from separate data frames\n\nMOTH_MORPHS <- read.csv(\"MOTH_MORPHS.csv\")\n\nstr(MOTH_MORPHS)\n\n##\n# Use 'left join' to add information from MOTH_MORPHS to MOTH_MASS.\n#\n# You can specify 'by = \"ID\"' if you want, but dplyr is clever and\n#  will find matching columns automatically!\n##\n\nleft_join(MOTH_MASS,\n          MOTH_MORPHS)\n\n##\n# You can then chain further commands on to this, if you like...\n##\n\nleft_join(MOTH_MASS,\n          MOTH_MORPHS) %>%\n  group_by(MORPH) %>%\n  summarise(Mass_mean = round(mean(MASS), digits = 2),\n            Mass_sd = round(sd(MASS), digits = 2))\n\n\n##### Bonus 2: Chaining ggplot2 commands ######\n\nlibrary(ggplot2)\n\nWEATHER %>% \n  select(Location, Year, Month, TempMax) %>% \n  filter(Year >= 2000 & Year <= 2010) %>%\n  ggplot(aes(x = Month, y = TempMax, colour = Year)) +\n  geom_point(size = 4, alpha = 0.5) + \n  stat_smooth() \n\nWEATHER %>% \n  select(Location, Year, Month, TempMax) %>% \n  filter(Year >= 2000 & Year <= 2010) %>%\n  ggplot(aes(x = Month, y = TempMax, colour = factor(Year))) +\n  geom_point(size = 4, alpha = 0.5) + \n  stat_smooth() \n\nWEATHER %>% \n  select(Location, Year, Month, TempMax) %>% \n  filter(Year >= 2000 & Year <= 2010) %>%\n  ggplot(aes(x = Month, y = TempMax, colour = factor(Year))) +\n  geom_point(size = 4, alpha = 0.5) + \n  stat_smooth() +\n  scale_x_continuous(breaks = 1:12,\n                     labels = c(\"Jan\", \"Feb\",\n                                \"Mar\", \"Apr\",\n                                \"May\", \"Jun\",\n                                \"Jul\", \"Aug\",\n                                \"Sep\", \"Oct\",\n                                \"Nov\", \"Dec\")) +\n  ylab(\"Maximum temperature (degrees C)\") +\n  theme_bw()\n\n## axis ticks??",
    "created" : 1448882069636.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3116357451",
    "id" : "1DD9DDE0",
    "lastKnownWriteTime" : 1448709810,
    "path" : "~/Documents/formations/R - Ecosse/courses/Mod_1_Intro_&_Data_Manip/AiR_DataManipulation_Script.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}